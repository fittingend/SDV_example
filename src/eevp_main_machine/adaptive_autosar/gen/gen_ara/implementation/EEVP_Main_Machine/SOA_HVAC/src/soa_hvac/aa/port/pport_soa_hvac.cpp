///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : pport_soa_hvac.cpp
/// SOFTWARE COMPONENT NAME           : PPort_SOA_HVAC
/// GENERATED DATE                    : 2025-08-30 10:53:37
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "soa_hvac/aa/port/pport_soa_hvac.h"
 
namespace eevp
{
namespace control
{
namespace skeleton
{
 
SoaHvacSkeletonImpl::SoaHvacSkeletonImpl(ara::core::InstanceSpecifier instanceSpec, ara::com::MethodCallProcessingMode mode)
    : SoaHvacSkeleton(instanceSpec, mode)
    , m_logger(ara::log::CreateLogger("SHVC", "PORT", ara::log::LogLevel::kVerbose))
    , m_SoaHvacSwVersion{0U}
    , m_soaHvacDeviceNormal{eevp::control::SoaDeviceIsNormal::kNORMAL}
    , m_soaHvacSetting{false, false, false, false, 0, 0, 0U, eevp::control::SoaHvacBlowDir::kCHEST, eevp::control::SoaHvacAirSource::kOUTER, false, false}
    , m_soaHvacStatus{false, false, false, false, 0, 0, 0U, eevp::control::SoaHvacBlowDir::kCHEST, eevp::control::SoaHvacAirSource::kOUTER, false, false}
    , m_soaHvacTemps{0, 0, 0, 0, 0, 0, 0, 0}
{
    // regist get handler, SoaHvacSwVersion
    auto soahvacswversion_get_handler = [this]() {
        return GetSoaHvacSwVersion();
    };
    SoaHvacSwVersion.RegisterGetHandler(soahvacswversion_get_handler);
    
    // regist get handler, soaHvacDeviceNormal
    auto soahvacdevicenormal_get_handler = [this]() {
        return GetsoaHvacDeviceNormal();
    };
    soaHvacDeviceNormal.RegisterGetHandler(soahvacdevicenormal_get_handler);
    
    // regist get handler, soaHvacSetting
    auto soahvacsetting_get_handler = [this]() {
        return GetsoaHvacSetting();
    };
    soaHvacSetting.RegisterGetHandler(soahvacsetting_get_handler);
    
    // regist get handler, soaHvacStatus
    auto soahvacstatus_get_handler = [this]() {
        return GetsoaHvacStatus();
    };
    soaHvacStatus.RegisterGetHandler(soahvacstatus_get_handler);
    
    // regist get handler, soaHvacTemps
    auto soahvactemps_get_handler = [this]() {
        return GetsoaHvacTemps();
    };
    soaHvacTemps.RegisterGetHandler(soahvactemps_get_handler);
}
 
void SoaHvacSkeletonImpl::SetAcOnOff(const bool& on)
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::SetAcOnOff::Triggered";
    
    // put your logic
}
 
void SoaHvacSkeletonImpl::SetAirSource(const eevp::control::SoaHvacAirSource& src)
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::SetAirSource::Triggered";
    
    // put your logic
}
 
void SoaHvacSkeletonImpl::SetAutoTemp(const bool& on)
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::SetAutoTemp::Triggered";
    
    // put your logic
}
 
void SoaHvacSkeletonImpl::SetBackwardDefrostOn(const bool& on)
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::SetBackwardDefrostOn::Triggered";
    
    // put your logic
}
 
void SoaHvacSkeletonImpl::SetBlowingDirection(const eevp::control::SoaHvacBlowDir& dir)
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::SetBlowingDirection::Triggered";
    
    // put your logic
}
 
void SoaHvacSkeletonImpl::SetBlowingForce(const std::uint8_t& force)
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::SetBlowingForce::Triggered";
    
    // put your logic
}
 
void SoaHvacSkeletonImpl::SetDriverTemp(const std::int8_t& temperature)
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::SetDriverTemp::Triggered";
    
    // put your logic
}
 
void SoaHvacSkeletonImpl::SetForwardDefrostOn(const bool& on)
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::SetForwardDefrostOn::Triggered";
    
    // put your logic
}
 
void SoaHvacSkeletonImpl::SetHvacPower(const bool& on)
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::SetHvacPower::Triggered";
    
    // put your logic
}
 
void SoaHvacSkeletonImpl::SetPassengerTemp(const std::int8_t& temperature)
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::SetPassengerTemp::Triggered";
    
    // put your logic
}
 
void SoaHvacSkeletonImpl::SetSync(const bool& on)
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::SetSync::Triggered";
    
    // put your logic
}
 
ara::core::Future<fields::SoaHvacSwVersion::FieldType> SoaHvacSkeletonImpl::GetSoaHvacSwVersion()
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::GetSoaHvacSwVersion::Requested";
    
    ara::core::Promise<fields::SoaHvacSwVersion::FieldType> promise;
    
    promise.set_value(m_SoaHvacSwVersion);
    return promise.get_future();
}
 
void SoaHvacSkeletonImpl::NotifySoaHvacSwVersion()
{
    auto notify = SoaHvacSwVersion.Update(m_SoaHvacSwVersion);
    if (notify.HasValue())
    {
        m_logger.LogVerbose() << "PPort_SOA_HVAC::NotifySoaHvacSwVersion::Update";
    }
    else
    {
        m_logger.LogError() << "PPort_SOA_HVAC::NotifySoaHvacSwVersion::Update::" << notify.Error().Message();
    }
}
 
void SoaHvacSkeletonImpl::UpdateSoaHvacSwVersion(const fields::SoaHvacSwVersion::FieldType& value)
{
    m_SoaHvacSwVersion = value;
}
 
ara::core::Future<fields::soaHvacDeviceNormal::FieldType> SoaHvacSkeletonImpl::GetsoaHvacDeviceNormal()
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::GetsoaHvacDeviceNormal::Requested";
    
    ara::core::Promise<fields::soaHvacDeviceNormal::FieldType> promise;
    
    promise.set_value(m_soaHvacDeviceNormal);
    return promise.get_future();
}
 
void SoaHvacSkeletonImpl::NotifysoaHvacDeviceNormal()
{
    auto notify = soaHvacDeviceNormal.Update(m_soaHvacDeviceNormal);
    if (notify.HasValue())
    {
        m_logger.LogVerbose() << "PPort_SOA_HVAC::NotifysoaHvacDeviceNormal::Update";
    }
    else
    {
        m_logger.LogError() << "PPort_SOA_HVAC::NotifysoaHvacDeviceNormal::Update::" << notify.Error().Message();
    }
}
 
void SoaHvacSkeletonImpl::UpdatesoaHvacDeviceNormal(const fields::soaHvacDeviceNormal::FieldType& value)
{
    m_soaHvacDeviceNormal = value;
}
 
ara::core::Future<fields::soaHvacSetting::FieldType> SoaHvacSkeletonImpl::GetsoaHvacSetting()
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::GetsoaHvacSetting::Requested";
    
    ara::core::Promise<fields::soaHvacSetting::FieldType> promise;
    
    promise.set_value(m_soaHvacSetting);
    return promise.get_future();
}
 
void SoaHvacSkeletonImpl::NotifysoaHvacSetting()
{
    auto notify = soaHvacSetting.Update(m_soaHvacSetting);
    if (notify.HasValue())
    {
        m_logger.LogVerbose() << "PPort_SOA_HVAC::NotifysoaHvacSetting::Update";
    }
    else
    {
        m_logger.LogError() << "PPort_SOA_HVAC::NotifysoaHvacSetting::Update::" << notify.Error().Message();
    }
}
 
void SoaHvacSkeletonImpl::UpdatesoaHvacSetting(const fields::soaHvacSetting::FieldType& value)
{
    m_soaHvacSetting = value;
}
 
ara::core::Future<fields::soaHvacStatus::FieldType> SoaHvacSkeletonImpl::GetsoaHvacStatus()
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::GetsoaHvacStatus::Requested";
    
    ara::core::Promise<fields::soaHvacStatus::FieldType> promise;
    
    promise.set_value(m_soaHvacStatus);
    return promise.get_future();
}
 
void SoaHvacSkeletonImpl::NotifysoaHvacStatus()
{
    auto notify = soaHvacStatus.Update(m_soaHvacStatus);
    if (notify.HasValue())
    {
        m_logger.LogVerbose() << "PPort_SOA_HVAC::NotifysoaHvacStatus::Update";
    }
    else
    {
        m_logger.LogError() << "PPort_SOA_HVAC::NotifysoaHvacStatus::Update::" << notify.Error().Message();
    }
}
 
void SoaHvacSkeletonImpl::UpdatesoaHvacStatus(const fields::soaHvacStatus::FieldType& value)
{
    m_soaHvacStatus = value;
}
 
ara::core::Future<fields::soaHvacTemps::FieldType> SoaHvacSkeletonImpl::GetsoaHvacTemps()
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::GetsoaHvacTemps::Requested";
    
    ara::core::Promise<fields::soaHvacTemps::FieldType> promise;
    
    promise.set_value(m_soaHvacTemps);
    return promise.get_future();
}
 
void SoaHvacSkeletonImpl::NotifysoaHvacTemps()
{
    auto notify = soaHvacTemps.Update(m_soaHvacTemps);
    if (notify.HasValue())
    {
        m_logger.LogVerbose() << "PPort_SOA_HVAC::NotifysoaHvacTemps::Update";
    }
    else
    {
        m_logger.LogError() << "PPort_SOA_HVAC::NotifysoaHvacTemps::Update::" << notify.Error().Message();
    }
}
 
void SoaHvacSkeletonImpl::UpdatesoaHvacTemps(const fields::soaHvacTemps::FieldType& value)
{
    m_soaHvacTemps = value;
}
 
} /// namespace skeleton
} /// namespace control
} /// namespace eevp

namespace soa_hvac
{
namespace aa
{
namespace port
{
 
PPort_SOA_HVAC::PPort_SOA_HVAC()
    : m_logger(ara::log::CreateLogger("SHVC", "PORT", ara::log::LogLevel::kVerbose))
    , m_running{false}
{
}
 
PPort_SOA_HVAC::~PPort_SOA_HVAC()
{
}
 
void PPort_SOA_HVAC::Start()
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::Start";
    
    // construct skeleton
    ara::core::InstanceSpecifier specifier{"SOA_HVAC/AA/PPort_SOA_HVAC"};
    m_interface = std::make_unique<eevp::control::skeleton::SoaHvacSkeletonImpl>(specifier);
    
    // offer service
    auto offer = m_interface->OfferService();
    if (offer.HasValue())
    {
        m_running = true;
        m_logger.LogVerbose() << "PPort_SOA_HVAC::Start::OfferService";
    }
    else
    {
        m_running = false;
        m_logger.LogError() << "PPort_SOA_HVAC::Start::OfferService::" << offer.Error().Message();
    }
}
 
void PPort_SOA_HVAC::Terminate()
{
    m_logger.LogVerbose() << "PPort_SOA_HVAC::Terminate";
    
    // stop port
    m_running = false;
    
    // stop offer service
    m_interface->StopOfferService();
    m_logger.LogVerbose() << "PPort_SOA_HVAC::Terminate::StopOfferService";
}
 
void PPort_SOA_HVAC::WriteValueSoaHvacSwVersion(const eevp::control::skeleton::fields::SoaHvacSwVersion::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdateSoaHvacSwVersion(value);
}
 
void PPort_SOA_HVAC::NotifyFieldSoaHvacSwVersionCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            m_interface->NotifySoaHvacSwVersion();
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_SOA_HVAC::NotifyFieldSoaHvacSwVersionTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->NotifySoaHvacSwVersion();
}
 
void PPort_SOA_HVAC::NotifyFieldSoaHvacSwVersionTriggered(const eevp::control::skeleton::fields::SoaHvacSwVersion::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdateSoaHvacSwVersion(value);
    m_interface->NotifySoaHvacSwVersion();
}
 
void PPort_SOA_HVAC::WriteValuesoaHvacDeviceNormal(const eevp::control::skeleton::fields::soaHvacDeviceNormal::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdatesoaHvacDeviceNormal(value);
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacDeviceNormalCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            m_interface->NotifysoaHvacDeviceNormal();
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacDeviceNormalTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->NotifysoaHvacDeviceNormal();
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacDeviceNormalTriggered(const eevp::control::skeleton::fields::soaHvacDeviceNormal::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdatesoaHvacDeviceNormal(value);
    m_interface->NotifysoaHvacDeviceNormal();
}
 
void PPort_SOA_HVAC::WriteValuesoaHvacSetting(const eevp::control::skeleton::fields::soaHvacSetting::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdatesoaHvacSetting(value);
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacSettingCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            m_interface->NotifysoaHvacSetting();
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacSettingTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->NotifysoaHvacSetting();
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacSettingTriggered(const eevp::control::skeleton::fields::soaHvacSetting::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdatesoaHvacSetting(value);
    m_interface->NotifysoaHvacSetting();
}
 
void PPort_SOA_HVAC::WriteValuesoaHvacStatus(const eevp::control::skeleton::fields::soaHvacStatus::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdatesoaHvacStatus(value);
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacStatusCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            m_interface->NotifysoaHvacStatus();
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacStatusTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->NotifysoaHvacStatus();
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacStatusTriggered(const eevp::control::skeleton::fields::soaHvacStatus::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdatesoaHvacStatus(value);
    m_interface->NotifysoaHvacStatus();
}
 
void PPort_SOA_HVAC::WriteValuesoaHvacTemps(const eevp::control::skeleton::fields::soaHvacTemps::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdatesoaHvacTemps(value);
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacTempsCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            m_interface->NotifysoaHvacTemps();
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacTempsTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->NotifysoaHvacTemps();
}
 
void PPort_SOA_HVAC::NotifyFieldsoaHvacTempsTriggered(const eevp::control::skeleton::fields::soaHvacTemps::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdatesoaHvacTemps(value);
    m_interface->NotifysoaHvacTemps();
}
 
} /// namespace port
} /// namespace aa
} /// namespace soa_hvac
 
/// EOF