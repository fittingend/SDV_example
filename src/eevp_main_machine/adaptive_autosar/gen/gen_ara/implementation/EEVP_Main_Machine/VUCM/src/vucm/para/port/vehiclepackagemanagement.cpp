///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : vehiclepackagemanagement.cpp
/// SOFTWARE COMPONENT NAME           : VehiclePackageManagement
/// GENERATED DATE                    : 2025-09-05 11:31:39
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "vucm/para/port/vehiclepackagemanagement.h"
 
namespace ara
{
namespace vucm
{
namespace pkgmgr
{
namespace skeleton
{
 
VehiclePackageManagementSkeletonImpl::VehiclePackageManagementSkeletonImpl(ara::core::InstanceSpecifier instanceSpec, ara::com::MethodCallProcessingMode mode)
    : VehiclePackageManagementSkeleton(instanceSpec, mode)
    , m_logger(ara::log::CreateLogger("VUCM", "PORT", ara::log::LogLevel::kVerbose))
    , m_RequestedPackage{"str_swnametype", "str_strongrevisionlabelstring"}
    , m_SafetyState{false}
    , m_TransferState{ara::ucm::TransferStateType::kIdle}
{
    // regist get handler, RequestedPackage
    auto requestedpackage_get_handler = [this]() {
        return GetRequestedPackage();
    };
    RequestedPackage.RegisterGetHandler(requestedpackage_get_handler);
    
    // regist get handler, SafetyState
    auto safetystate_get_handler = [this]() {
        return GetSafetyState();
    };
    SafetyState.RegisterGetHandler(safetystate_get_handler);
    
    // regist get handler, TransferState
    auto transferstate_get_handler = [this]() {
        return GetTransferState();
    };
    TransferState.RegisterGetHandler(transferstate_get_handler);
}
 
ara::core::Future<VehiclePackageManagementSkeleton::AllowCampaignOutput> VehiclePackageManagementSkeletonImpl::AllowCampaign()
{
    m_logger.LogVerbose() << "VehiclePackageManagement::AllowCampaign::Requested";
    
    AllowCampaignOutput response;
    ara::core::Promise<AllowCampaignOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<VehiclePackageManagementSkeleton::CancelCampaignOutput> VehiclePackageManagementSkeletonImpl::CancelCampaign(const bool& DisableCampaign)
{
    m_logger.LogVerbose() << "VehiclePackageManagement::CancelCampaign::Requested";
    
    CancelCampaignOutput response;
    ara::core::Promise<CancelCampaignOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<VehiclePackageManagementSkeleton::DeleteTransferOutput> VehiclePackageManagementSkeletonImpl::DeleteTransfer(const ara::ucm::TransferIdType& id)
{
    m_logger.LogVerbose() << "VehiclePackageManagement::DeleteTransfer::Requested";
    
    DeleteTransferOutput response;
    ara::core::Promise<DeleteTransferOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<VehiclePackageManagementSkeleton::GetCampaignHistoryOutput> VehiclePackageManagementSkeletonImpl::GetCampaignHistory(const std::uint64_t& timestampGE, const std::uint64_t& timestampLT)
{
    m_logger.LogVerbose() << "VehiclePackageManagement::GetCampaignHistory::Requested";
    
    GetCampaignHistoryOutput response;
    ara::core::Promise<GetCampaignHistoryOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<VehiclePackageManagementSkeleton::GetSwClusterInfoOutput> VehiclePackageManagementSkeletonImpl::GetSwClusterInfo()
{
    m_logger.LogVerbose() << "VehiclePackageManagement::GetSwClusterInfo::Requested";
    
    GetSwClusterInfoOutput response;
    ara::core::Promise<GetSwClusterInfoOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<VehiclePackageManagementSkeleton::GetSwPackagesOutput> VehiclePackageManagementSkeletonImpl::GetSwPackages()
{
    m_logger.LogVerbose() << "VehiclePackageManagement::GetSwPackages::Requested";
    
    GetSwPackagesOutput response;
    ara::core::Promise<GetSwPackagesOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<VehiclePackageManagementSkeleton::SwPackageInventoryOutput> VehiclePackageManagementSkeletonImpl::SwPackageInventory(const ara::ucm::SwNameVersionVectorType& AvailableSoftwarePackages)
{
    m_logger.LogVerbose() << "VehiclePackageManagement::SwPackageInventory::Requested";
    
    SwPackageInventoryOutput response;
    ara::core::Promise<SwPackageInventoryOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<VehiclePackageManagementSkeleton::TransferDataOutput> VehiclePackageManagementSkeletonImpl::TransferData(const ara::ucm::TransferIdType& id, const ara::ucm::ByteVectorType& data, const std::uint64_t& blockCounter)
{
    m_logger.LogVerbose() << "VehiclePackageManagement::TransferData::Requested";
    
    TransferDataOutput response;
    ara::core::Promise<TransferDataOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<VehiclePackageManagementSkeleton::TransferExitOutput> VehiclePackageManagementSkeletonImpl::TransferExit(const ara::ucm::TransferIdType& id)
{
    m_logger.LogVerbose() << "VehiclePackageManagement::TransferExit::Requested";
    
    TransferExitOutput response;
    ara::core::Promise<TransferExitOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<VehiclePackageManagementSkeleton::TransferStartOutput> VehiclePackageManagementSkeletonImpl::TransferStart(const ara::ucm::SwNameType& SoftwarePackageName, const std::uint64_t& size)
{
    m_logger.LogVerbose() << "VehiclePackageManagement::TransferStart::Requested";
    
    TransferStartOutput response;
    ara::core::Promise<TransferStartOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<VehiclePackageManagementSkeleton::TransferVehiclePackageOutput> VehiclePackageManagementSkeletonImpl::TransferVehiclePackage(const std::uint64_t& size)
{
    m_logger.LogVerbose() << "VehiclePackageManagement::TransferVehiclePackage::Requested";
    
    TransferVehiclePackageOutput response;
    ara::core::Promise<TransferVehiclePackageOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<fields::RequestedPackage::FieldType> VehiclePackageManagementSkeletonImpl::GetRequestedPackage()
{
    m_logger.LogVerbose() << "VehiclePackageManagement::GetRequestedPackage::Requested";
    
    ara::core::Promise<fields::RequestedPackage::FieldType> promise;
    
    promise.set_value(m_RequestedPackage);
    return promise.get_future();
}
 
void VehiclePackageManagementSkeletonImpl::NotifyRequestedPackage()
{
    auto notify = RequestedPackage.Update(m_RequestedPackage);
    if (notify.HasValue())
    {
        m_logger.LogVerbose() << "VehiclePackageManagement::NotifyRequestedPackage::Update";
    }
    else
    {
        m_logger.LogError() << "VehiclePackageManagement::NotifyRequestedPackage::Update::" << notify.Error().Message();
    }
}
 
void VehiclePackageManagementSkeletonImpl::UpdateRequestedPackage(const fields::RequestedPackage::FieldType& value)
{
    m_RequestedPackage = value;
}
 
ara::core::Future<fields::SafetyState::FieldType> VehiclePackageManagementSkeletonImpl::GetSafetyState()
{
    m_logger.LogVerbose() << "VehiclePackageManagement::GetSafetyState::Requested";
    
    ara::core::Promise<fields::SafetyState::FieldType> promise;
    
    promise.set_value(m_SafetyState);
    return promise.get_future();
}
 
void VehiclePackageManagementSkeletonImpl::NotifySafetyState()
{
    auto notify = SafetyState.Update(m_SafetyState);
    if (notify.HasValue())
    {
        m_logger.LogVerbose() << "VehiclePackageManagement::NotifySafetyState::Update";
    }
    else
    {
        m_logger.LogError() << "VehiclePackageManagement::NotifySafetyState::Update::" << notify.Error().Message();
    }
}
 
void VehiclePackageManagementSkeletonImpl::UpdateSafetyState(const fields::SafetyState::FieldType& value)
{
    m_SafetyState = value;
}
 
ara::core::Future<fields::TransferState::FieldType> VehiclePackageManagementSkeletonImpl::GetTransferState()
{
    m_logger.LogVerbose() << "VehiclePackageManagement::GetTransferState::Requested";
    
    ara::core::Promise<fields::TransferState::FieldType> promise;
    
    promise.set_value(m_TransferState);
    return promise.get_future();
}
 
void VehiclePackageManagementSkeletonImpl::NotifyTransferState()
{
    auto notify = TransferState.Update(m_TransferState);
    if (notify.HasValue())
    {
        m_logger.LogVerbose() << "VehiclePackageManagement::NotifyTransferState::Update";
    }
    else
    {
        m_logger.LogError() << "VehiclePackageManagement::NotifyTransferState::Update::" << notify.Error().Message();
    }
}
 
void VehiclePackageManagementSkeletonImpl::UpdateTransferState(const fields::TransferState::FieldType& value)
{
    m_TransferState = value;
}
 
} /// namespace skeleton
} /// namespace pkgmgr
} /// namespace vucm
} /// namespace ara

namespace vucm
{
namespace para
{
namespace port
{
 
VehiclePackageManagement::VehiclePackageManagement()
    : m_logger(ara::log::CreateLogger("VUCM", "PORT", ara::log::LogLevel::kVerbose))
    , m_running{false}
{
}
 
VehiclePackageManagement::~VehiclePackageManagement()
{
}
 
void VehiclePackageManagement::Start()
{
    m_logger.LogVerbose() << "VehiclePackageManagement::Start";
    
    // construct skeleton
    ara::core::InstanceSpecifier specifier{"VUCM/PARA/VehiclePackageManagement"};
    m_interface = std::make_unique<ara::vucm::pkgmgr::skeleton::VehiclePackageManagementSkeletonImpl>(specifier);
    
    // offer service
    auto offer = m_interface->OfferService();
    if (offer.HasValue())
    {
        m_running = true;
        m_logger.LogVerbose() << "VehiclePackageManagement::Start::OfferService";
    }
    else
    {
        m_running = false;
        m_logger.LogError() << "VehiclePackageManagement::Start::OfferService::" << offer.Error().Message();
    }
}
 
void VehiclePackageManagement::Terminate()
{
    m_logger.LogVerbose() << "VehiclePackageManagement::Terminate";
    
    // stop port
    m_running = false;
    
    // stop offer service
    m_interface->StopOfferService();
    m_logger.LogVerbose() << "VehiclePackageManagement::Terminate::StopOfferService";
}
 
void VehiclePackageManagement::WriteValueRequestedPackage(const ara::vucm::pkgmgr::skeleton::fields::RequestedPackage::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdateRequestedPackage(value);
}
 
void VehiclePackageManagement::NotifyFieldRequestedPackageCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            m_interface->NotifyRequestedPackage();
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void VehiclePackageManagement::NotifyFieldRequestedPackageTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->NotifyRequestedPackage();
}
 
void VehiclePackageManagement::NotifyFieldRequestedPackageTriggered(const ara::vucm::pkgmgr::skeleton::fields::RequestedPackage::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdateRequestedPackage(value);
    m_interface->NotifyRequestedPackage();
}
 
void VehiclePackageManagement::WriteValueSafetyState(const ara::vucm::pkgmgr::skeleton::fields::SafetyState::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdateSafetyState(value);
}
 
void VehiclePackageManagement::NotifyFieldSafetyStateCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            m_interface->NotifySafetyState();
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void VehiclePackageManagement::NotifyFieldSafetyStateTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->NotifySafetyState();
}
 
void VehiclePackageManagement::NotifyFieldSafetyStateTriggered(const ara::vucm::pkgmgr::skeleton::fields::SafetyState::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdateSafetyState(value);
    m_interface->NotifySafetyState();
}
 
void VehiclePackageManagement::WriteValueTransferState(const ara::vucm::pkgmgr::skeleton::fields::TransferState::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdateTransferState(value);
}
 
void VehiclePackageManagement::NotifyFieldTransferStateCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            m_interface->NotifyTransferState();
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void VehiclePackageManagement::NotifyFieldTransferStateTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->NotifyTransferState();
}
 
void VehiclePackageManagement::NotifyFieldTransferStateTriggered(const ara::vucm::pkgmgr::skeleton::fields::TransferState::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdateTransferState(value);
    m_interface->NotifyTransferState();
}
 
} /// namespace port
} /// namespace para
} /// namespace vucm
 
/// EOF