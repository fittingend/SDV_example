///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                        
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                              
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                           
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.             
///                                                                                                        
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : packagemanagement.cpp
/// SOFTWARE COMPONENT NAME           : PackageManagement
/// GENERATED DATE                    : 2025-08-30 10:53:49
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "ucm/para/port/packagemanagement.h"
 
namespace ara
{
namespace ucm
{
namespace pkgmgr
{
namespace skeleton
{
 
PackageManagementSkeletonImpl::PackageManagementSkeletonImpl(ara::core::InstanceSpecifier instanceSpec, ara::com::MethodCallProcessingMode mode)
    : PackageManagementSkeleton(instanceSpec, mode)
    , m_logger(ara::log::CreateLogger("UCM", "PORT", ara::log::LogLevel::kVerbose))
    , m_CurrentStatus{ara::ucm::PackageManagerStatusType::kIdle}
{
    // regist get handler, CurrentStatus
    auto currentstatus_get_handler = [this]() {
        return GetCurrentStatus();
    };
    CurrentStatus.RegisterGetHandler(currentstatus_get_handler);
}
 
ara::core::Future<PackageManagementSkeleton::ActivateOutput> PackageManagementSkeletonImpl::Activate()
{
    m_logger.LogVerbose() << "PackageManagement::Activate::Requested";
    
    ActivateOutput response;
    ara::core::Promise<ActivateOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::CancelOutput> PackageManagementSkeletonImpl::Cancel(const ara::ucm::TransferIdType& id)
{
    m_logger.LogVerbose() << "PackageManagement::Cancel::Requested";
    
    CancelOutput response;
    ara::core::Promise<CancelOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::DeleteTransferOutput> PackageManagementSkeletonImpl::DeleteTransfer(const ara::ucm::TransferIdType& id)
{
    m_logger.LogVerbose() << "PackageManagement::DeleteTransfer::Requested";
    
    DeleteTransferOutput response;
    ara::core::Promise<DeleteTransferOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::FinishOutput> PackageManagementSkeletonImpl::Finish()
{
    m_logger.LogVerbose() << "PackageManagement::Finish::Requested";
    
    FinishOutput response;
    ara::core::Promise<FinishOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::GetHistoryOutput> PackageManagementSkeletonImpl::GetHistory(const std::uint64_t& timestampGE, const std::uint64_t& timestampLT)
{
    m_logger.LogVerbose() << "PackageManagement::GetHistory::Requested";
    
    GetHistoryOutput response;
    ara::core::Promise<GetHistoryOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::GetIdOutput> PackageManagementSkeletonImpl::GetId()
{
    m_logger.LogVerbose() << "PackageManagement::GetId::Requested";
    
    GetIdOutput response;
    ara::core::Promise<GetIdOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::GetSwClusterChangeInfoOutput> PackageManagementSkeletonImpl::GetSwClusterChangeInfo()
{
    m_logger.LogVerbose() << "PackageManagement::GetSwClusterChangeInfo::Requested";
    
    GetSwClusterChangeInfoOutput response;
    ara::core::Promise<GetSwClusterChangeInfoOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::GetSwClusterDescriptionOutput> PackageManagementSkeletonImpl::GetSwClusterDescription()
{
    m_logger.LogVerbose() << "PackageManagement::GetSwClusterDescription::Requested";
    
    GetSwClusterDescriptionOutput response;
    ara::core::Promise<GetSwClusterDescriptionOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::GetSwClusterInfoOutput> PackageManagementSkeletonImpl::GetSwClusterInfo()
{
    m_logger.LogVerbose() << "PackageManagement::GetSwClusterInfo::Requested";
    
    GetSwClusterInfoOutput response;
    ara::core::Promise<GetSwClusterInfoOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::GetSwPackagesOutput> PackageManagementSkeletonImpl::GetSwPackages()
{
    m_logger.LogVerbose() << "PackageManagement::GetSwPackages::Requested";
    
    GetSwPackagesOutput response;
    ara::core::Promise<GetSwPackagesOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::GetSwProcessProgressOutput> PackageManagementSkeletonImpl::GetSwProcessProgress(const ara::ucm::TransferIdType& id)
{
    m_logger.LogVerbose() << "PackageManagement::GetSwProcessProgress::Requested";
    
    GetSwProcessProgressOutput response;
    ara::core::Promise<GetSwProcessProgressOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::ProcessSwPackageOutput> PackageManagementSkeletonImpl::ProcessSwPackage(const ara::ucm::TransferIdType& id)
{
    m_logger.LogVerbose() << "PackageManagement::ProcessSwPackage::Requested";
    
    ProcessSwPackageOutput response;
    ara::core::Promise<ProcessSwPackageOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::RevertProcessedSwPackagesOutput> PackageManagementSkeletonImpl::RevertProcessedSwPackages()
{
    m_logger.LogVerbose() << "PackageManagement::RevertProcessedSwPackages::Requested";
    
    RevertProcessedSwPackagesOutput response;
    ara::core::Promise<RevertProcessedSwPackagesOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::RollbackOutput> PackageManagementSkeletonImpl::Rollback()
{
    m_logger.LogVerbose() << "PackageManagement::Rollback::Requested";
    
    RollbackOutput response;
    ara::core::Promise<RollbackOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::TransferDataOutput> PackageManagementSkeletonImpl::TransferData(const ara::ucm::TransferIdType& id, const ara::ucm::ByteVectorType& data, const std::uint64_t& blockCounter)
{
    m_logger.LogVerbose() << "PackageManagement::TransferData::Requested";
    
    TransferDataOutput response;
    ara::core::Promise<TransferDataOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::TransferExitOutput> PackageManagementSkeletonImpl::TransferExit(const ara::ucm::TransferIdType& id)
{
    m_logger.LogVerbose() << "PackageManagement::TransferExit::Requested";
    
    TransferExitOutput response;
    ara::core::Promise<TransferExitOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<PackageManagementSkeleton::TransferStartOutput> PackageManagementSkeletonImpl::TransferStart(const std::uint64_t& size)
{
    m_logger.LogVerbose() << "PackageManagement::TransferStart::Requested";
    
    TransferStartOutput response;
    ara::core::Promise<TransferStartOutput> promise;
    
    // put your logic
    
    promise.set_value(response);
    return promise.get_future();
}
 
ara::core::Future<fields::CurrentStatus::FieldType> PackageManagementSkeletonImpl::GetCurrentStatus()
{
    m_logger.LogVerbose() << "PackageManagement::GetCurrentStatus::Requested";
    
    ara::core::Promise<fields::CurrentStatus::FieldType> promise;
    
    promise.set_value(m_CurrentStatus);
    return promise.get_future();
}
 
void PackageManagementSkeletonImpl::NotifyCurrentStatus()
{
    auto notify = CurrentStatus.Update(m_CurrentStatus);
    if (notify.HasValue())
    {
        m_logger.LogVerbose() << "PackageManagement::NotifyCurrentStatus::Update";
    }
    else
    {
        m_logger.LogError() << "PackageManagement::NotifyCurrentStatus::Update::" << notify.Error().Message();
    }
}
 
void PackageManagementSkeletonImpl::UpdateCurrentStatus(const fields::CurrentStatus::FieldType& value)
{
    m_CurrentStatus = value;
}
 
} /// namespace skeleton
} /// namespace pkgmgr
} /// namespace ucm
} /// namespace ara

namespace ucm
{
namespace para
{
namespace port
{
 
PackageManagement::PackageManagement()
    : m_logger(ara::log::CreateLogger("UCM", "PORT", ara::log::LogLevel::kVerbose))
    , m_running{false}
{
}
 
PackageManagement::~PackageManagement()
{
}
 
void PackageManagement::Start()
{
    m_logger.LogVerbose() << "PackageManagement::Start";
    
    // construct skeleton
    ara::core::InstanceSpecifier specifier{"UCM/PARA/PackageManagement"};
    m_interface = std::make_unique<ara::ucm::pkgmgr::skeleton::PackageManagementSkeletonImpl>(specifier);
    
    // offer service
    auto offer = m_interface->OfferService();
    if (offer.HasValue())
    {
        m_running = true;
        m_logger.LogVerbose() << "PackageManagement::Start::OfferService";
    }
    else
    {
        m_running = false;
        m_logger.LogError() << "PackageManagement::Start::OfferService::" << offer.Error().Message();
    }
}
 
void PackageManagement::Terminate()
{
    m_logger.LogVerbose() << "PackageManagement::Terminate";
    
    // stop port
    m_running = false;
    
    // stop offer service
    m_interface->StopOfferService();
    m_logger.LogVerbose() << "PackageManagement::Terminate::StopOfferService";
}
 
void PackageManagement::WriteValueCurrentStatus(const ara::ucm::pkgmgr::skeleton::fields::CurrentStatus::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdateCurrentStatus(value);
}
 
void PackageManagement::NotifyFieldCurrentStatusCyclic()
{
    while (m_running)
    {
        {
            std::lock_guard<std::mutex> lock(m_mutex);
            
            m_interface->NotifyCurrentStatus();
        }
        std::this_thread::sleep_for(std::chrono::seconds(1));
    }
}
 
void PackageManagement::NotifyFieldCurrentStatusTriggered()
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->NotifyCurrentStatus();
}
 
void PackageManagement::NotifyFieldCurrentStatusTriggered(const ara::ucm::pkgmgr::skeleton::fields::CurrentStatus::FieldType& value)
{
    std::lock_guard<std::mutex> lock(m_mutex);
    
    m_interface->UpdateCurrentStatus(value);
    m_interface->NotifyCurrentStatus();
}
 
} /// namespace port
} /// namespace para
} /// namespace ucm
 
/// EOF