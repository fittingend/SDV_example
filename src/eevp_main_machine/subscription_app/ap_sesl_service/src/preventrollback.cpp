///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                      
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                            
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                        
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.          
///                                                                                                      
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : preventrollback.cpp
/// SOFTWARE COMPONENT NAME           : PreventRollback
/// GENERATED DATE                    : 2025-08-29 17:14:22
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "preventrollback/aa/preventrollback.h"
#include "ara/exec/execution_client.h" 
#include <thread>
#include <chrono>

namespace preventrollback {
namespace aa {

PreventRollback::PreventRollback()
    : m_logger(ara::log::CreateLogger("PRRB", "SWC", ara::log::LogLevel::kInfo))
    , m_running{false}
    , m_workers(6)
{
    m_logger.LogInfo() << __func__;
}

PreventRollback::~PreventRollback()
{
    m_logger.LogInfo() << __func__;
}

bool PreventRollback::Initialize()
{
    m_logger.LogInfo() << "PreventRollback::Initialize";

    bool init = true;

    m_RPortMain_PDW_Service        = std::make_unique<preventrollback::aa::port::RPortMain_PDW_Service>();
    m_RPortBCM_ExteriorSignal      = std::make_unique<preventrollback::aa::port::RPortBCM_ExteriorSignal>();
    m_RPortAccrPedal               = std::make_unique<preventrollback::aa::port::RPortAccrPedal>();
    m_RPortBrakePedal              = std::make_unique<preventrollback::aa::port::RPortBrakePedal>();
    m_RPortGear                    = std::make_unique<preventrollback::aa::port::RPortGear>();
    m_RPortSoaVehicleInfo          = std::make_unique<preventrollback::aa::port::RPortSoaVehicleInfo>();
    m_RPortSubscriptionManagement  = std::make_unique<preventrollback::aa::port::RPortSubscriptionManagement>();

    m_RPortSubscriptionManagement->RegistEventHandlernotifySubscriptionInfo(
        [this](const eevp::subscription::service::proxy::events::notifySubscriptionInfo::SampleType& info) {
            onNotifySubscriptionInfo(info);   
        });

    m_RPortSubscriptionManagement->RegistResponseHandlergetSubscriptionInfo(
        [this](const eevp::subscription::service::proxy::methods::getSubscriptionInfo::Output& out) {
            onGetSubscriptionInfoResponse(out);
        });

    // ===== BCM 상태 관찰 핸들러 =====
    m_RPortBCM_ExteriorSignal->RegistFieldHandlerhornState(
        [this](const eevp::simulation::proxy::fields::hornState::FieldType& v) { onHorn(v); });
    m_RPortBCM_ExteriorSignal->RegistFieldHandlerlightState(
        [this](const eevp::simulation::proxy::fields::lightState::FieldType& v) { onLight(v); });

    // ===== PDW 이벤트/필드 핸들러 =====
    m_RPortMain_PDW_Service->RegistEventHandlerDistanceLevel(
        [this](const eevp::pdw::service::proxy::events::DistanceLevel::SampleType& dl) { onDistanceLevel(dl); });
    m_RPortMain_PDW_Service->RegistFieldHandlerUssStatus(
        [this](const eevp::pdw::service::proxy::fields::UssStatus::FieldType& st) { onUssStatus(st); });

    return init;
}

static bool ReportRunningState(ara::log::Logger& logger)
{
    ara::exec::ExecutionClient execClient;
    auto res = execClient.ReportExecutionState(ara::exec::ExecutionState::kRunning);
    if (res.HasValue()) {
        logger.LogInfo() << "PreventRollback app in Running State";
        return true;
    } else {
        logger.LogError() << "ReportExecutionState failed: " << res.Error().Message();
        return false;
    }
}

void PreventRollback::Start()
{
    m_logger.LogInfo() << "PreventRollback::Start";

    if (!ReportRunningState(m_logger)) {
        m_logger.LogError() << "Continue without running-state report";
    }

    m_RPortMain_PDW_Service->Start();
    m_RPortBCM_ExteriorSignal->Start();
    m_RPortAccrPedal->Start();
    m_RPortBrakePedal->Start();
    m_RPortGear->Start();
    m_RPortSoaVehicleInfo->Start();
    m_RPortSubscriptionManagement->Start();

    m_workers.Async([this]{
        std::this_thread::sleep_for(std::chrono::seconds(5));
        requestSubscriptionInfo();
    });
}

void PreventRollback::Run()
{
    m_logger.LogInfo() << "PreventRollback::Run";
    m_running = true;

    m_workers.Async([this]{
        while (m_running) {
            std::unique_lock<std::mutex> lock(mSubscriptionMutex);
            if (!mSubscriptionCv.wait_for(lock, std::chrono::seconds(5),
                                          [&]{ return mSubscription || !m_running; })) {
                m_logger.LogInfo() << "Still unsubscribed... waiting.";
                continue;
            }
            if (!m_running) break;

            m_logger.LogInfo() << "App is subscribed. Starting main logic.";
            while (mSubscription && m_running) {
                std::this_thread::sleep_for(std::chrono::seconds(1));
            }
            if (!mSubscription) {
                m_logger.LogInfo() << "App is unsubscribed. Pausing logic.";
            }
        }
    });

    m_workers.Async([this]{ m_RPortSubscriptionManagement->ReceiveEventnotifySubscriptionInfoCyclic(); });
    m_workers.Async([this]{ m_RPortMain_PDW_Service->ReceiveEventDistanceLevelCyclic(); });
    m_workers.Async([this]{ m_RPortMain_PDW_Service->ReceiveFieldUssStatusCyclic(); });
    m_workers.Async([this]{ m_RPortBCM_ExteriorSignal->ReceiveFieldhornStateCyclic(); });
    m_workers.Async([this]{ m_RPortBCM_ExteriorSignal->ReceiveFieldlightStateCyclic(); });
    m_workers.Async([this]{ m_RPortSoaVehicleInfo->ReceiveFieldsoaVehicleInfoCyclic(); });

    m_workers.Wait();
    m_logger.LogInfo() << "PreventRollback::Run finished";
}

void PreventRollback::Terminate()
{
    m_logger.LogInfo() << "PreventRollback::Terminate";
    {
        std::lock_guard<std::mutex> lock(mSubscriptionMutex);
        m_running = false;
        mSubscription = false;
    }
    mSubscriptionCv.notify_all();

    m_RPortMain_PDW_Service->Terminate();
    m_RPortBCM_ExteriorSignal->Terminate();
    m_RPortAccrPedal->Terminate();
    m_RPortBrakePedal->Terminate();
    m_RPortGear->Terminate();
    m_RPortSoaVehicleInfo->Terminate();
    m_RPortSubscriptionManagement->Terminate();

    m_logger.LogInfo() << "Ports terminated";
}

void PreventRollback::onHorn(const eevp::simulation::proxy::fields::hornState::FieldType& v)
{
    std::lock_guard<std::mutex> lk(mDataMutex);
    if (mHornState != v) {
        mHornState = v;
        m_logger.LogInfo() << "BCM hornState=" << (mHornState == eevp::simulation::type::BCM_HornState::ON ? "ON" : "OFF");
    }
}

void PreventRollback::onLight(const eevp::simulation::proxy::fields::lightState::FieldType& v)
{
    std::lock_guard<std::mutex> lk(mDataMutex);
    if (mLightState != v) {
        mLightState = v;
        m_logger.LogInfo() << "BCM lightState=" << (mLightState == eevp::simulation::type::BCM_HeadlightState::ON ? "ON" : "OFF");
    }
}

void PreventRollback::onDistanceLevel(const eevp::pdw::service::proxy::events::DistanceLevel::SampleType& dl)
{
    std::lock_guard<std::mutex> lk(mDataMutex);

    // 값 범위: 0~3, 7(에러) — 범위 외 값도 그대로 로그에 남김
    const auto dir = dl.SensorDirection;
    PdwSnapshot* target = nullptr;
    if (dir == eevp::pdw::type::Direction::kFront) {
        target = &mFrontDL;
    } else {
        target = &mRearDL;
    }

    target->left   = dl.Left;
    target->right  = dl.Right;
    target->center = dl.Center;
    target->valid  = true;

    m_logger.LogVerbose() << "PDW(" << (dir==eevp::pdw::type::Direction::kFront ? "Front" : "Rear")
                          << ") L/R/C=" << uint32_t(dl.Left) << "/" << uint32_t(dl.Right) << "/" << uint32_t(dl.Center);

    if (mSubscription) {
        evaluateDecisionsLocked();
    }
}

void PreventRollback::onUssStatus(const eevp::pdw::service::proxy::fields::UssStatus::FieldType& st)
{
    std::lock_guard<std::mutex> lk(mDataMutex);

    auto oldF = mFrontUssState;
    auto oldR = mRearUssState;

    if (st.SensorDirection == eevp::pdw::type::Direction::kFront) {
        mFrontUssState = st.SensorStatus;
        if (mFrontUssState != eevp::pdw::type::State::NORMAL) {
            m_logger.LogWarn() << "PDW Front status=" << (mFrontUssState == eevp::pdw::type::State::ERROR ? "ERROR" : "UNKNOWN");
        }
    } else {
        mRearUssState = st.SensorStatus;
        if (mRearUssState != eevp::pdw::type::State::NORMAL) {
            m_logger.LogWarn() << "PDW Rear status=" << (mRearUssState == eevp::pdw::type::State::ERROR ? "ERROR" : "UNKNOWN");
        }
    }

    if (mSubscription && (oldF != mFrontUssState || oldR != mRearUssState)) {
        evaluateDecisionsLocked();
    }
}

// ===== 평가 로직 =====

int PreventRollback::riskOf(uint8_t l, uint8_t r, uint8_t c)
{
    // 7(에러)가 하나라도 있으면 최우선 ERROR 취급
    if (l == 7 || r == 7 || c == 7) return 99; //ERROR 마커
    uint8_t mx = std::max({l, r, c});
    if (mx >= 3) return 3;   //CRITICAL
    if (mx == 2) return 2;   //NEAR
    if (mx == 1) return 1;   //FAR
    return 0;                //NONE
}

const char* PreventRollback::riskStr(int r)
{
    switch (r) {
        case 0:  return "NONE";
        case 1:  return "FAR";
        case 2:  return "NEAR";
        case 3:  return "CRITICAL";
        case 99: return "ERROR";
        default: return "UNK";
    }
}

void PreventRollback::evaluateDecisionsLocked()
{
    // 전/후방 유효 시 위험도 계산
    int frontRisk = mFrontDL.valid ? riskOf(mFrontDL.left, mFrontDL.right, mFrontDL.center) : -1;
    int rearRisk  = mRearDL .valid ? riskOf(mRearDL.left , mRearDL.right , mRearDL.center ) : -1;

    // 동일 결과면 로그 억제
    if (frontRisk == mLastDecision.frontRisk && rearRisk == mLastDecision.rearRisk) {
        return;
    }

    mLastDecision.frontRisk = frontRisk;
    mLastDecision.rearRisk  = rearRisk;

    // 개별 리포트
    if (frontRisk >= 0) {
        m_logger.LogInfo() << "[PDW] Front risk=" << riskStr(frontRisk)
                           << " (L/R/C=" << uint32_t(mFrontDL.left) << "/" << uint32_t(mFrontDL.right) << "/" << uint32_t(mFrontDL.center) << ")";
    }
    if (rearRisk >= 0) {
        m_logger.LogInfo() << "[PDW] Rear  risk=" << riskStr(rearRisk)
                           << " (L/R/C=" << uint32_t(mRearDL.left) << "/" << uint32_t(mRearDL.right) << "/" << uint32_t(mRearDL.center) << ")";
    }

    // 상황 해석(로그만)
    const bool frontCritical = (frontRisk == 3 || frontRisk == 99);
    const bool rearCritical  = (rearRisk  == 3 || rearRisk  == 99);

    if (frontCritical || rearCritical) {
        m_logger.LogInfo() << "[Decision] Obstacle CRITICAL → Horn/Light ALERT suggested (no control issued)";
    }

    if (frontCritical && !rearCritical) {
        m_logger.LogInfo() << "[Decision] Acceleration suppression suggested (front close)";
    }

    // USS 상태 기반 경고
    if (mFrontUssState != eevp::pdw::type::State::NORMAL || mRearUssState != eevp::pdw::type::State::NORMAL) {
        m_logger.LogWarn() << "[PDW] USS status abnormal: Front="
                           << (mFrontUssState==eevp::pdw::type::State::NORMAL? "NORMAL":"ERROR")
                           << ", Rear="
                           << (mRearUssState==eevp::pdw::type::State::NORMAL? "NORMAL":"ERROR");
    }

    // ※ 실제 Set 동작은 프록시에 메소드가 없어 호출 생략
    // trySetHorn()/trySetLight() 훅은 추후 Provider/Proxy가 생기면 연결
}

// ==== Subscription Management ====

void PreventRollback::requestSubscriptionInfo()
{
    m_logger.LogInfo() << "PreventRollback::getSubscriptionInfo";
    m_RPortSubscriptionManagement->RequestgetSubscriptionInfo(kAppName);
}

void PreventRollback::onGetSubscriptionInfoResponse(
    const eevp::subscription::service::proxy::methods::getSubscriptionInfo::Output& out)
{
    const bool isSub = out.isSubscription;

    {
        std::lock_guard<std::mutex> lock(mSubscriptionMutex);
        mSubscription = isSub;
    }

    if (mSubscription) {
        m_logger.LogInfo() << "App subscribed → waking up logic";
        mSubscriptionCv.notify_all();
    } else {
        m_logger.LogInfo() << "App unsubscribed on initial check";
    }
}

void PreventRollback::onNotifySubscriptionInfo(
    const eevp::subscription::service::proxy::events::notifySubscriptionInfo::SampleType& info)
{
    m_logger.LogInfo() << __func__;

    if (info.appName == kAppName) {
        {
            std::lock_guard<std::mutex> lock(mSubscriptionMutex);
            mSubscription = info.isSubscription;
        }
        if (mSubscription) {
            m_logger.LogInfo() << "App subscribed → waking up logic";
            mSubscriptionCv.notify_all();
        } else {
            m_logger.LogInfo() << "App unsubscribed → logic will pause";
        }
    }
}
} // namespace aa
} // namespace preventrollback
