///////////////////////////////////////////////////////////////////////////////////////////////////////////
///                                                                                                      
/// Copyright, 2021 PopcornSAR Co., Ltd. All rights reserved.                                            
/// This software is copyright protected and proprietary to PopcornSAR Co., Ltd.                        
/// PopcornSAR Co., Ltd. grants to you only those rights as set out in the license conditions.          
///                                                                                                      
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// AUTOSAR VERSION                   : R20-11
/// GENERATED BY                      : PARA, Adaptive Application Generator
///////////////////////////////////////////////////////////////////////////////////////////////////////////
/// GENERATED FILE NAME               : preventrollback.cpp
/// SOFTWARE COMPONENT NAME           : PreventRollback
/// GENERATED DATE                    : 2025-08-29 17:14:22
///////////////////////////////////////////////////////////////////////////////////////////////////////////
#include "preventrollback/aa/preventrollback.h"
#include "ara/exec/execution_client.h"

#include <atomic>
#include <algorithm>
#include <chrono>
#include <condition_variable>
#include <cstdint>
#include <mutex>
#include <thread>

using namespace std::chrono_literals;

namespace preventrollback {
namespace aa {

using eevp::pdw::type::State;      // NORMAL / ERROR ...
using eevp::pdw::type::Direction;  // kFront / kRear

namespace {

static const eevp::type::String kAppName{"PreventRollback"};

std::atomic_bool g_running{false};
std::atomic_bool g_subscribed{false};
std::mutex g_sub_mtx;
std::condition_variable g_sub_cv;

struct PdwSnapshot {
    std::uint8_t front_lvl{0};  // 0=없음, 1~3=근접 단계, 7=에러(가정)
    std::uint8_t rear_lvl{0};
    bool         uss_ok{false};
};
PdwSnapshot g_pdw;

// Execution State 보고
bool ReportRunningState(ara::log::Logger& log) {
    ara::exec::ExecutionClient ec;
    auto r = ec.ReportExecutionState(ara::exec::ExecutionState::kRunning);
    if (r.HasValue()) {
        log.LogInfo() << "PreventRollback Running";
        return true;
    }
    log.LogError() << "ReportExecutionState failed";
    return false;
}

// 로직:
// 1) 앞쪽 레벨>=1 → 경적 (여기선 로그만)
// 2) 앞쪽 레벨>=3 → 경적 + 기어상태 알림 + 가속페달 알림(모니터)
// 3) 뒤쪽 레벨>=3 → 브레이크 상태 알림(모니터)
void EvaluateAndAct(
    ara::log::Logger& logger,
    preventrollback::aa::port::RPortBCM_ExteriorSignal* 
    preventrollback::aa::port::RPortVCS_Gear*           pGear,
    preventrollback::aa::port::RPortVCS_AccrPedal*      pAcc,
    preventrollback::aa::port::RPortVCS_BrakePedal*     pBrake)
{
    if (!g_pdw.uss_ok) {
        logger.LogWarn() << "[LOGIC] USS not normal; actions skipped";
        return;
    }

    const auto f = g_pdw.front_lvl;
    const auto r = g_pdw.rear_lvl;

    const bool any_error = (f == 7) || (r == 7);
    if (any_error) {
        logger.LogError() << "[LOGIC] PDW level=7 (error detected); skip";
        return;
    }

    // 1. 앞쪽 7m 근접(레벨>=1 가정) → 경고음
    if (f >= 1) {
        logger.LogWarn() << "[ACTION] FRONT: warn beep (>=1)";
    }

    // 2. 앞쪽 3m 이내(레벨>=3 가정) → 경고음 + R 기어 요청 모니터 + 가속페달 알림
    if (f >= 3) {
        logger.LogWarn() << "[ACTION] FRONT EMER (>=3): gear notify + accr notify + beep";
        if (pGear)  { pGear->RequestnotifyGear(); }
        if (pAcc)   { pAcc->RequestnotifyAccrPedal(); }
    }

    // 3. 뒤쪽 3m 이내(레벨>=3 가정) → 브레이크 알림
    if (r >= 3) {
        logger.LogWarn() << "[ACTION] REAR EMER (>=3): brake notify";
        if (pBrake) { pBrake->RequestnotifyBrakeStatus(); }
    }
}

}


PreventRollback::PreventRollback()
: m_logger(ara::log::CreateLogger("PRRB", "SWC", ara::log::LogLevel::kInfo))
, m_running(false)
, m_workers(4)
{
    m_logger.LogInfo() << "PreventRollback::PreventRollback()";
}

PreventRollback::~PreventRollback() {
    m_logger.LogInfo() << "PreventRollback::~PreventRollback()";
}

//==================================================================================================
// Initialize
//==================================================================================================
bool PreventRollback::Initialize()
{
    m_logger.LogInfo() << "PreventRollback::Initialize";

    m_RPortSubscriptionManagement = std::make_unique<preventrollback::aa::port::RPortSubscriptionManagement>();
    m_RPortBCM_ExteriorSignal     = std::make_unique<preventrollback::aa::port::RPortBCM_ExteriorSignal>();
    m_RPortMain_PDW_Service       = std::make_unique<preventrollback::aa::port::RPortMain_PDW_Service>();
    m_RPortSoaVehicleInfo         = std::make_unique<preventrollback::aa::port::RPortSoaVehicleInfo>();
    m_RPortVCS_BrakePedal         = std::make_unique<preventrollback::aa::port::RPortVCS_BrakePedal>();
    m_RPortVCS_AccrPedal          = std::make_unique<preventrollback::aa::port::RPortVCS_AccrPedal>();
    m_RPortVCS_Gear               = std::make_unique<preventrollback::aa::port::RPortVCS_Gear>();

    return true;
}

//==================================================================================================
// Start
//==================================================================================================
void PreventRollback::Start()
{
    m_logger.LogInfo() << "PreventRollback::Start";

    m_RPortSubscriptionManagement->Start();
    m_RPortBCM_ExteriorSignal->Start();
    m_RPortMain_PDW_Service->Start();
    m_RPortSoaVehicleInfo->Start();
    m_RPortVCS_BrakePedal->Start();
    m_RPortVCS_AccrPedal->Start();
    m_RPortVCS_Gear->Start();

    // 구독 이벤트
    m_RPortSubscriptionManagement->RegistEventHandlernotifySubscriptionInfo(
        [this](const eevp::subscription::service::proxy::events::notifySubscriptionInfo::SampleType& v) {
            if (v.appName == kAppName) {
                {
                    std::lock_guard<std::mutex> lk(g_sub_mtx);
                    g_subscribed = v.isSubscription;
                }
                m_logger.LogInfo() << "[SUBM] notify: " << v.appName.c_str()
                                   << " subscribed=" << (v.isSubscription ? "true" : "false");
                g_sub_cv.notify_all();
            } else {
                m_logger.LogInfo() << "[SUBM] notify ignored for appName=" << v.appName.c_str();
            }
        });

    m_RPortSubscriptionManagement->RegistResponseHandlergetSubscriptionInfo(
        [this](const eevp::subscription::service::proxy::methods::getSubscriptionInfo::Output& out) {
            {
                std::lock_guard<std::mutex> lk(g_sub_mtx);
                g_subscribed = out.isSubscription;
            }
            m_logger.LogInfo() << "[SUBM] get: subscribed=" << (out.isSubscription ? "true" : "false");
            g_sub_cv.notify_all();
        });

    // PDW: DistanceLevel
    m_RPortMain_PDW_Service->RegistEventHandlerDistanceLevel(
        [this](const eevp::pdw::service::proxy::events::DistanceLevel::SampleType& s) {
            const std::uint8_t lvlL = s.Left;
            const std::uint8_t lvlC = s.Center;
            const std::uint8_t lvlR = s.Right;

            const std::uint8_t lvlMin = std::min(lvlL, std::min(lvlC, lvlR));

            if (s.SensorDirection == Direction::kFront) {
                g_pdw.front_lvl = lvlMin;
            } else {
                g_pdw.rear_lvl = lvlMin;
            }

            m_logger.LogInfo()
                << "[PDW] dir=" << (s.SensorDirection == Direction::kFront ? "Front" : "Rear")
                << " L/C/R=" << int(lvlL) << "/" << int(lvlC) << "/" << int(lvlR)
                << " -> lvl(min)=" << int(lvlMin);

            EvaluateAndAct(m_logger,
                           m_RPortBCM_ExteriorSignal.get(),
                           m_RPortVCS_Gear.get(),
                           m_RPortVCS_AccrPedal.get(),
                           m_RPortVCS_BrakePedal.get());
        });

    // PDW: UssStatus
    m_RPortMain_PDW_Service->RegistFieldHandlerUssStatus(
        [this](const eevp::pdw::service::proxy::fields::UssStatus::FieldType& f) {
            g_pdw.uss_ok = (f.SensorStatus == State::NORMAL);
            m_logger.LogInfo() << "[PDW] UssStatus=" << (g_pdw.uss_ok ? "NORMAL" : "NOT-NORMAL");

            EvaluateAndAct(m_logger,
                           m_RPortBCM_ExteriorSignal.get(),
                           m_RPortVCS_Gear.get(),
                           m_RPortVCS_AccrPedal.get(),
                           m_RPortVCS_BrakePedal.get());
        });
}

//==================================================================================================
// Terminate
//==================================================================================================
void PreventRollback::Terminate()
{
    m_logger.LogInfo() << "PreventRollback::Terminate";

    g_running = false;
    {
        std::lock_guard<std::mutex> lk(g_sub_mtx);
        g_subscribed = false;
    }
    g_sub_cv.notify_all();

    m_RPortVCS_Gear->Terminate();
    m_RPortVCS_AccrPedal->Terminate();
    m_RPortVCS_BrakePedal->Terminate();
    m_RPortSoaVehicleInfo->Terminate();
    m_RPortMain_PDW_Service->Terminate();
    m_RPortBCM_ExteriorSignal->Terminate();
    m_RPortSubscriptionManagement->Terminate();
}

//==================================================================================================
// Run
//==================================================================================================
void PreventRollback::Run()
{
    m_logger.LogInfo() << "PreventRollback::Run";

    if (!ReportRunningState(m_logger)) {
        m_logger.LogError() << "ReportRunningState failed";
        return;
    }

    // 최초 구독 상태 질의 (반드시 appName 전달)
    m_logger.LogInfo() << "PreventRollback::getSubscriptionInfo";
    m_RPortSubscriptionManagement->RequestgetSubscriptionInfo(kAppName);

    g_running = true;
    auto next_log = std::chrono::steady_clock::now();

    while (g_running) {
        {
            std::unique_lock<std::mutex> lk(g_sub_mtx);
            g_sub_cv.wait_for(lk, 100ms, [] { return g_subscribed.load(); });
        }

        if (!g_subscribed.load()) {
            auto now = std::chrono::steady_clock::now();
            if (now >= next_log) {
                m_logger.LogInfo() << "Still unsubscribed... waiting.";
                next_log = now + 5s;
            }
            continue;
        }

        EvaluateAndAct(m_logger,
                       m_RPortBCM_ExteriorSignal.get(),
                       m_RPortVCS_Gear.get(),
                       m_RPortVCS_AccrPedal.get(),
                       m_RPortVCS_BrakePedal.get());

        std::this_thread::sleep_for(500ms);
    }
}

} // namespace aa
} // namespace preventrollback